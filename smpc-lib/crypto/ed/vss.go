/*
 *  Copyright (C) 2020-2021  AnySwap Ltd. All rights reserved.
 *  Copyright (C) 2020-2021  xing.chang@anyswap.exchange
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the Apache License, Version 2.0.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */

package ed

import (
	"bytes"
	cryptorand "crypto/rand"
	"fmt"
	"io"
	"errors"
	"math/big"
)

// Vss  Calculate secret sharing value 
func Vss(secret [32]byte, ids [][32]byte, t int, n int) ([][32]byte, [][32]byte, [][32]byte,error) {
    // check 1 < threshold <= n ?
    if t <= 1 || t > n {
	return nil,nil,nil,fmt.Errorf("threshold must > 1 and <= n")
    }

    var cfs, cfsBBytes, shares [][32]byte

    cfs = append(cfs, secret)

    var cfB ExtendedGroupElement
    var cfBBytes [32]byte
    GeScalarMultBase(&cfB, &secret)
    cfB.ToBytes(&cfBBytes)
    cfsBBytes = append(cfsBBytes, cfBBytes)

    var zero [32]byte
    var one [32]byte
    one[0] = 1
    rand := cryptorand.Reader

    for i := 1; i <= t-1; i++ {
	    var rndNum [32]byte
	    if _, err := io.ReadFull(rand, rndNum[:]); err != nil {
		    fmt.Println("Error: io.ReadFull(rand, rndNum[:])")
		    return shares,shares,shares,fmt.Errorf("generate the random number fail")
	    }
	    ScMulAdd(&rndNum, &rndNum, &one, &zero)

	    cfs = append(cfs, rndNum)

	    GeScalarMultBase(&cfB, &rndNum)
	    cfB.ToBytes(&cfBBytes)
	    cfsBBytes = append(cfsBBytes, cfBBytes)
    }

    for i := 0; i < n; i++ {
	    share,err := calculatePolynomial(cfs, ids[i])
	    if err != nil {
		return nil,nil,nil,err
	    }

	    shares = append(shares, share)
    }

    return cfs, cfsBBytes, shares,nil
}

// Vss2  Calculate secret sharing value 
func Vss2(secret [32]byte, t int, n int, uids map[string][32]byte) ([][32]byte, [][32]byte, map[string][32]byte,error) {
    // check 1 < threshold <= n ?
    if t <= 1 || t > n {
	return nil,nil,nil,fmt.Errorf("threshold must > 1 and <= n")
    }

    var cfs, cfsBBytes [][32]byte
    var shares = make(map[string][32]byte)

    cfs = append(cfs, secret)

    var cfB ExtendedGroupElement
    var cfBBytes [32]byte
    GeScalarMultBase(&cfB, &secret)
    cfB.ToBytes(&cfBBytes)
    cfsBBytes = append(cfsBBytes, cfBBytes)

    var zero [32]byte
    var one [32]byte
    one[0] = 1
    rand := cryptorand.Reader

    for i := 1; i <= t-1; i++ {
	    var rndNum [32]byte
	    if _, err := io.ReadFull(rand, rndNum[:]); err != nil {
		    fmt.Println("Error: io.ReadFull(rand, rndNum[:])")
		    var ret [][32]byte
		    return ret,ret,shares,err
	    }
	    ScMulAdd(&rndNum, &rndNum, &one, &zero)

	    cfs = append(cfs, rndNum)

	    GeScalarMultBase(&cfB, &rndNum)
	    cfB.ToBytes(&cfBBytes)
	    cfsBBytes = append(cfsBBytes, cfBBytes)
    }

    for k, v := range uids {
	    share,err := calculatePolynomial(cfs, v)
	    if err != nil {
		return nil,nil,nil,err
	    }

	    shares[k] = share
    }

    return cfs, cfsBBytes, shares,nil
}

// VerifyVss verify secret sharing value
func VerifyVss(share [32]byte, id [32]byte, cfsBBytes [][32]byte) bool {
	var rlt1, rlt2, tem ExtendedGroupElement

	rlt1.FromBytes(&cfsBBytes[0])

	idVal := id

	for i := 1; i < len(cfsBBytes); i++ {
		tem.FromBytes(&cfsBBytes[i])
		GeScalarMult(&tem, &idVal, &tem)

		GeAdd(&rlt1, &rlt1, &tem)
		ScMul(&idVal, &idVal, &id)
	}

	GeScalarMultBase(&rlt2, &share)

	var rlt1Bytes, rlt2Bytes [32]byte
	rlt1.ToBytes(&rlt1Bytes)
	rlt2.ToBytes(&rlt2Bytes)

	if bytes.Equal(rlt1Bytes[:], rlt2Bytes[:]) {
		return true
	}

	return false
}

// Combine  Calculate the function value of Lagrange polynomial 
func Combine(shares [][32]byte, ids [][32]byte) [32]byte {
	var one [32]byte
	one[0] = 1

	order := GetBytesOrder()
	var secret [32]byte

	for j := 0; j < len(shares); j++ {
		var times [32]byte
		times[0] = 1

		// calculate times()
		for i := 0; i < len(shares); i++ {
			if j != i {
				var time [32]byte
				ScSub(&time, &ids[i], &ids[j])
				time = ScModInverse(time, order)

				ScMul(&time, &time, &ids[i])

				ScMul(&times, &times, &time)
			}
		}

		// calculate sum(f(x) * times())
		var sTimes [32]byte
		ScMul(&sTimes, &shares[j], &times)

		ScAdd(&secret, &sTimes, &secret)
	}
	// fmt.Println()
	return secret
}

func calculatePolynomial(cfs [][32]byte, id [32]byte) ([32]byte,error) {
    // the shares are generated by evaluating the polynomial with the other nodes’ID’s. It is critical that these node ID’s are non-zero, or zero modulo the order of the curve
    zero,_ := new(big.Int).SetString("0",10)
    idnum := new(big.Int).SetBytes(id[:])
    idnum2 := new(big.Int).Mod(idnum,GetBigIntOrder())
    if idnum.Cmp(zero) == 0 || idnum2.Cmp(zero) == 0 {
	var ret [32]byte
	return ret,errors.New("id can not be equal to 0 or 0 modulo the order of the curve")
    }

	lastIndex := len(cfs) - 1
	result := cfs[lastIndex]

	for i := lastIndex - 1; i >= 0; i-- {
		ScMul(&result, &result, &id)
		ScAdd(&result, &result, &cfs[i])
	}

	return result,nil
}
