package ed_ristretto

import (
	r255 "github.com/gtank/ristretto255"
	"errors"
	"fmt"
)

// Vss  Calculate secret sharing value
func Vss(secret [32]byte, ids [][32]byte, t int, n int) ([][32]byte, [][32]byte, [][32]byte, error) {
	// check 1 < threshold <= n
	if t <= 1 || t > n {
		return nil, nil, nil, fmt.Errorf("threshold must > 1 and <= n")
	}	
	
	secretScalar, err := BytesReduceToScalar(secret[:])
	if err != nil {
		return nil, nil, nil, err
	}

	var cfs, cfsBBytes, shares [][32]byte
	cfs = append(cfs, secret)

	var cfBBytes [32]byte
	cfB := new(r255.Element).ScalarBaseMult(secretScalar)
	cfB.Encode(cfBBytes[:0])
	cfsBBytes = append(cfsBBytes, cfBBytes)

	for i := 1; i <= t-1; i++ { // todo
		var rndNumBytes [32]byte
		rndNum, err := NewRandomScalar()
		if err != nil {
			return nil, nil, nil, err
		}
		rndNum.Encode(rndNumBytes[:0])
		cfs = append(cfs, rndNumBytes)

		var cfBBytes [32]byte
		cfB := new(r255.Element).ScalarBaseMult(rndNum)
		cfB.Encode(cfBBytes[:0])
		cfsBBytes = append(cfsBBytes, cfBBytes)
	}

	for i := 0; i < n; i++ {
		share, err := calculatePolynomial(cfs, ids[i])
		if err != nil {
			return nil, nil, nil, err
		}

		shares = append(shares, share)
	}

	return cfs, cfsBBytes, shares, nil
}

// VerifyVss verify secret sharing value
func VerifyVss(share [32]byte, id [32]byte, cfsBBytes [][32]byte) bool {
	var(
		rlt1 = new(r255.Element)
		rlt2 = new(r255.Element)
		tem = new(r255.Element)
	)

	rlt1.Decode(cfsBBytes[0][:0])
	idBackup, err := BytesReduceToScalar(id[:])
	idVal, err := BytesReduceToScalar(id[:])
	if err != nil {
		return false
	}

	for i := 1; i < len(cfsBBytes); i++ {
		tem.Decode(cfsBBytes[i][:0])
		tem = new(r255.Element).ScalarMult(idVal, tem)
		rlt1 = new(r255.Element).Add(rlt1, tem)
		idVal = new(r255.Scalar).Multiply(idVal, idBackup)
	}

	shareScalar, err := BytesReduceToScalar(share[:])
	if err != nil {
		return false
	}
	rlt2 = new(r255.Element).ScalarBaseMult(shareScalar)

	return rlt1.Equal(rlt2) == 1
}

// Combine  Calculate the function value of Lagrange polynomial
func Combine(shares [][32]byte, ids [][32]byte) [32]byte {
	var defaultRlt [32]byte

	var idScalars []*r255.Scalar
	var shareScalars []*r255.Scalar
	for i := 0; i < len(ids); i++ {
		temId, err := BytesReduceToScalar(ids[i][:])
		if err != nil {
			return defaultRlt
		}

		temShare, err := BytesReduceToScalar(shares[i][:])
		if err != nil {
			return defaultRlt
		}

		idScalars = append(idScalars, temId)
		shareScalars = append(shareScalars, temShare)
	}

	var secret = r255.NewScalar()
	var secretBytes [32]byte

	for j := 0; j < len(shares); j++ {
		var times = ScalarOne()

		// calculate times()
		for i := 0; i < len(shares); i++ {
			if j != i {
				var time = r255.NewScalar()
				time = new(r255.Scalar).Subtract(idScalars[i], idScalars[j])
				time = new(r255.Scalar).Invert(time)

				if time.Equal(r255.NewScalar()) == 1 {
					return defaultRlt
				}

				time = new(r255.Scalar).Multiply(idScalars[i], time)
				times = new(r255.Scalar).Multiply(times, time)
			}
		}

		// calculate sum(f(x) * times())
		sTimes := new(r255.Scalar).Multiply(shareScalars[j], times)
		secret = new(r255.Scalar).Add(secret, sTimes)
	}

	secret.Encode(secretBytes[:0])
	return secretBytes
}

func calculatePolynomial(cfs [][32]byte, id [32]byte) ([32]byte, error) {
	// the shares are generated by evaluating the polynomial with the other nodes’ID’s. It is critical that these node ID’s are non-zero, or zero modulo the order of the curve
	var defaultRlt [32]byte
	
	idScalar, err := BytesReduceToScalar(id[:])
	if err != nil {
		return defaultRlt, err
	}

	if idScalar.Equal(r255.NewScalar()) == 1 {
		return defaultRlt, errors.New("id can not be equal to 0 or 0 modulo the order of the curve")
	}

	lastIndex := len(cfs) - 1
	resultScalar, err := BytesReduceToScalar(cfs[lastIndex][:])
	if err != nil {
		return defaultRlt, err
	}

	for i := lastIndex - 1; i >= 0; i-- {
		temScalar, err := BytesReduceToScalar(cfs[i][:])
		if err != nil {
			return defaultRlt, err
		}

		resultScalar = new(r255.Scalar).Multiply(resultScalar, idScalar)
		resultScalar = new(r255.Scalar).Add(resultScalar, temScalar)
	}

	var resultBytes [32]byte
	resultScalar.Encode(resultBytes[:0])

	return resultBytes, nil
}
