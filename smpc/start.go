/*
 *  Copyright (C) 2020-2021  AnySwap Ltd. All rights reserved.
 *  Copyright (C) 2020-2021  haijun.cai@anyswap.exchange
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the Apache License, Version 2.0.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */

package smpc

import (
	p2psmpc "github.com/anyswap/FastMulThreshold-DSA/p2p/layer2"
	smpclibec2 "github.com/anyswap/FastMulThreshold-DSA/tss-lib/ec2"
	"github.com/fsn-dev/cryptoCoins/coins"
	cryptocoinsconfig "github.com/fsn-dev/cryptoCoins/coins/config"
	"github.com/fsn-dev/cryptoCoins/coins/eos"
	"os"
	"github.com/anyswap/FastMulThreshold-DSA/p2p/discover"
	"time"
	"encoding/json"
	tss "github.com/anyswap/FastMulThreshold-DSA/smpc/tss/smpc"
	"net"
	"io"
	"github.com/anyswap/FastMulThreshold-DSA/smpc/socket"
	"github.com/anyswap/FastMulThreshold-DSA/log"
)

var (
	curEnode    string
	initTimes   = 0
	recalcTimes = 1

	// KeyFile bootnode keyfile
	KeyFile      string
	
	RelayInPeers      bool

	Tee      bool
	TeeIP      string
	TeePort      string
	
	//TeeParamDataCh = make(chan string,1)
	AttestationCh = make(chan string,1)
	DataKeyCh = make(chan string,1)
	TeeEnodeIDCh = make(chan string,1)
)

func init() {
	p2psmpc.RegisterRecvCallback(Call2)
	p2psmpc.SdkProtocol_registerBroadcastInGroupCallback(Call)
	p2psmpc.RegisterCallback(Call)

	RegP2pGetGroupCallBack(p2psmpc.SdkProtocol_getGroup)
	RegP2pSendToGroupAllNodesCallBack(p2psmpc.SdkProtocol_SendToGroupAllNodes)
	RegP2pGetSelfEnodeCallBack(p2psmpc.GetSelfID)
	RegP2pBroadcastInGroupOthersCallBack(p2psmpc.SdkProtocol_broadcastInGroupOthers)
	RegP2pSendMsgToPeerCallBack(p2psmpc.SendMsgToPeer)
	RegP2pParseNodeCallBack(p2psmpc.ParseNodeID)
	RegSmpcGetEosAccountCallBack(eos.GetEosAccount)
	InitChan()
}

//------------------------------------------------------------------------

// LunchParams lunch params
type LunchParams struct {
	WaitMsg      uint64
	TryTimes     uint64
	PreSignNum   uint64
	Jobs   uint64
	MaxAcceptTime    uint64
	Bip32Pre     uint64
	SyncPreSign string
	RelayInPeers bool
	AutoPreSign bool
	TestNet bool
	NeighRelay bool
	Tee bool
	TeeIP string
	TeePort string
}

// Start init gsmpc
// 1. Initialization: local database (including general database, private key database, bip32 c value database,bip32 pre-sign data database, pre-sign data database, public key group information database, database for saving data related to generate pubkey command, database for saving data related to signature command, database for saving data related to resare command, pubkey), P2P callback function, Crypto coins configuration, startup parameters (including the number of pre generated packets, the timeout waiting for P2P information, the number of automatic retries after failed address application or signature, the timeout agreed by the nodes, whether to synchronize pre generated packets between nodes, etc.), and the enodeid of the local node.
// 2. Load the pubkeys generated by history and execute it only once.
// 3. Generate 4 large prime numbers
// 4. Execute automatic pre generation of data packets.
// 5. Listen for the arrival of the sign command.
// 6. Delete the data related to generating pubkey command, the signature command and the restore command from the corresponding sub database, and correspondingly change the status of the command data to timeout in the general database.
func Start(params *LunchParams) {

	cryptocoinsconfig.Init()
	coins.Init()

	curEnode = p2psmpc.GetSelfID()
	accloaded := AccountLoaded()

	go smpclibec2.GenRandomSafePrime()

	log.Debug("======================smpc.Start======================", "accounts loaded", accloaded, "cache", cache, "handles", handles, "cur enode", curEnode)
	err := StartSmpcLocalDb()
	if err != nil {
		info := "======================smpc.Start," + err.Error() + ",so terminate smpc node startup"
		log.Error(info)
		os.Exit(1)
		return
	}

	//get p2p group db
	err = discover.GetSmpcGidDb(curEnode)
	if err != nil {
		info := "======================smpc.Start," + err.Error() + ",so terminate smpc node startup"
		log.Error(info)
		os.Exit(1)
	}
	//

	log.Debug("======================smpc.Start,open all db success======================", "curEnode", curEnode)

	PrePubDataCount = int(params.PreSignNum)
	WaitMsgTimeGG20 = int(params.WaitMsg)
	recalcTimes = int(params.TryTimes)
	waitallgg20 = WaitMsgTimeGG20 * recalcTimes
	MaxAcceptTime = int(params.MaxAcceptTime)
	PreBip32DataCount = int(params.Bip32Pre)
	if params.SyncPreSign == "true" {
		syncpresign = true
	} else {
		syncpresign = false
	}

	if params.AutoPreSign {
	    AutoPreGenSignData()
	}

	go HandleRPCSign()

	// do this must after openning accounts db success,but get accloaded must before it
	if !accloaded {
		go CopyAllAccountsFromDb()
	}

	CleanUpAllReqAddrInfo()
	CleanUpAllSignInfo()
	CleanUpAllReshareInfo()

	InitMpcNodeInfo()

	RelayInPeers = params.RelayInPeers
	discover.NeighRelay = params.NeighRelay

	RPCMaxWorker = int(params.Jobs)
	RPCMaxQueue = int(params.Jobs)

	go CleanUpMsgReceiv()

	Tee = params.Tee
	TeeIP = params.TeeIP
	TeePort = params.TeePort

	if Tee {
	    go TeeClient(TeeIP,TeePort)
	    
	    dir := GetTeeParamDataDir()
	    if !socket.Exists(dir) {
		err := os.Mkdir(dir,os.ModePerm)
		if err != nil {
		    return
		}

		time.Sleep(time.Duration(30) * time.Second)
		go GetAttestationFromLib()
		go GetDataKeyFromLib()
	    } else {
		path1 := dir + "/enodeID"
		path2 := dir + "/enc_enodeID_priv"
		path3 := dir + "/attestation"
		path4 := dir + "/enc_datakey"

		if !socket.Exists(path3) {
		    time.Sleep(time.Duration(30) * time.Second)
		    go GetAttestationFromLib()
		}

		if !socket.Exists(path2) || !socket.Exists(path4) {
		    //wait for socket client
		    time.Sleep(time.Duration(30) * time.Second)
		    go GetDataKeyFromLib()
		} else {
		    if !socket.Exists(path1) {
			time.Sleep(time.Duration(30) * time.Second)
			go GetEnodeIDFromLib()
		    }
		}
	    }
	}

	log.Info("================================smpc.Start,init finish.========================", "curEnode", curEnode, "waitmsg", WaitMsgTimeGG20, "trytimes", recalcTimes,"presignnum", PrePubDataCount, "bip32pre", PreBip32DataCount)
}

// TODO
func ExecGetKey() (string,error) {
    return "ACCKEY",nil
}

//TODO
func ExecGetSk() (string,error) {
    return "ACCSK",nil
}

//TODO
func ExecGetToken() (string,error) {
    return "Token",nil
}

func GetAttestationFromLib() error {
    acckey,err := ExecGetKey()
    if err != nil {
	return err
    }

    accsk,err := ExecGetSk()
    if err != nil {
	return err
    }

    token,err := ExecGetToken()
    if err != nil {
	return err
    }

    s := &socket.GetAttestation{AccKey:acckey,AccSk:accsk,Token:token}
    err = socket.SendMsgData(tss.VSocketConnect,s)
    if err != nil {
	return err
    }
   
    kgs := <-AttestationCh
    msgmap := make(map[string]string)
    err = json.Unmarshal([]byte(kgs), &msgmap)
    if err != nil {
	return err
    }

    dir := GetTeeParamDataDir()
    if !socket.Exists(dir) {
	err := os.Mkdir(dir,os.ModePerm)
	if err != nil {
	    return err
	}
    }

    path := dir + "/attestation"

    if socket.WriteFile(path,msgmap["attestation"]) != nil {
	log.Error("=========================GetAttestationFromLib,write data to file fail====================")
	os.Exit(1)
    }

    return nil
}

func GetDataKeyFromLib() error {
    var err error
    s := &socket.GetDataKey{}
    err = socket.SendMsgData(tss.VSocketConnect,s)
    if err != nil {
	return err
    }
   
    kgs := <-DataKeyCh
    msgmap := make(map[string]string)
    err = json.Unmarshal([]byte(kgs), &msgmap)
    if err != nil {
	return err
    }

    dir := GetTeeParamDataDir()
    if !socket.Exists(dir) {
	err := os.Mkdir(dir,os.ModePerm)
	if err != nil {
	    return err
	}
    }

    path1 := dir + "/enodeID"
    path2 := dir + "/enc_enodeID_priv"
    path3 := dir + "/enc_datakey"

    if socket.WriteFile(path1,msgmap["enodeID"]) != nil || socket.WriteFile(path2,msgmap["enc_enodeID_priv"]) != nil || socket.WriteFile(path3,msgmap["enc_datakey"]) != nil {
	os.Exit(1)
    }

    return nil
}

func GetEnodeIDFromLib() error {
    var err error

    dir := GetTeeParamDataDir()
    path1 := dir + "/enc_enodeID_priv"
    path2 := dir + "/enc_datakey"
    enc_enodeID_priv,err := socket.ReadFile(path1)
    if err != nil {
	return err
    }
    
    enc_datakey,err := socket.ReadFile(path2)
    if err != nil {
	return err
    }
    
    s := &socket.GetTeeEnodeID{EncPriv:enc_enodeID_priv,EncDataKey:enc_datakey}
    err = socket.SendMsgData(tss.VSocketConnect,s)
    if err != nil {
	return err
    }
   
    kgs := <-TeeEnodeIDCh
    msgmap := make(map[string]string)
    err = json.Unmarshal([]byte(kgs), &msgmap)
    if err != nil {
	return err
    }

    path := dir + "/enodeID"

    if socket.WriteFile(path,msgmap["tee_enodeID"]) != nil {
	os.Exit(1)
    }

    return nil
}

/*type TeeParamData struct {
    EnodeID string
    EncEnodePriv string
    Attestation string
    EncDataKey string
}

func GetTeeParamData() error {
    acckey,err := ExecGetKey()
    if err != nil {
	return err
    }

    accsk,err := ExecGetSk()
    if err != nil {
	return err
    }

    token,err := ExecGetToken()
    if err != nil {
	return err
    }

    s := &socket.GetTeeParamData{AccKey:acckey,AccSk:accsk,Token:token}
    err = socket.SendMsgData(tss.VSocketConnect,s)
    if err != nil {
	return err
    }
   
    kgs := <-TeeParamDataCh
    msgmap := make(map[string]string)
    err = json.Unmarshal([]byte(kgs), &msgmap)
    if err != nil {
	log.Error("=========================GetTeeParamData,unmarshal msg error====================","err",err,"msg",kgs)
	return err
    }

    ret := &TeeParamData{}
    err = json.Unmarshal([]byte(msgmap["TeeParamData"]),ret)
    if err != nil {
	log.Error("=========================GetTeeParamData,unmarshal teeparamdata error====================","err",err)
	return err
    }

    if ret.EnodeID == "" || ret.EncEnodePriv == "" || ret.Attestation == "" || ret.EncDataKey == "" {
	log.Error("=========================GetTeeParamData,tee param data error====================","err",err)
	return errors.New("param error")
    }

    dir := GetTeeParamDataDir()
    err = os.Mkdir(dir,os.ModePerm)
    if err != nil {
	log.Error("===================GetTeeParamData,mkdir error====================","err",err)
	return err
    }

    path1 := dir + "/enodeID"
    path2 := dir + "/enc_enodeID_priv"
    path3 := dir + "/attestation"
    path4 := dir + "/enc_datakey"

    if socket.WriteFile(path1,ret.EnodeID) != nil || socket.WriteFile(path2,ret.EncEnodePriv) != nil || socket.WriteFile(path3,ret.Attestation) != nil || socket.WriteFile(path4,ret.EncDataKey) != nil {
	log.Error("=========================GetTeeParamData,write data to file fail====================")
	os.Exit(1)
    }

    return nil
}
*/

func TeeClient(teeip string,teeport string) {
    if teeip == "" || teeport == "" {
	return
    }

    addr := teeip + ":" + teeport
    socket.ServerAddress = addr
    
    for true {
	conn, err := net.Dial(socket.ServerNetworkType,socket.ServerAddress)
	if err != nil {
	    time.Sleep(time.Duration(1000000))
	   continue 
	}
       
	tss.VSocketConnect = conn

	for true {
	    msg, err := socket.Read(conn)
	    log.Info("=================socket client,finish reading msg================","msg",msg,"err",err)
	    if err != nil {
		if err == io.EOF {
		    log.Error("socket client,connection closed", "addr",conn.RemoteAddr())
		    break
		} else {
		    log.Error("socket client read error", "err",err)
		    time.Sleep(time.Duration(1000000))
		    continue
		}
	    }
	    
	    ////////
	    if msg == "" {
		log.Error("==============socket client,recieved msg from server fail===============")
		time.Sleep(time.Duration(1000000))
		continue
	    }

	    msgmap := make(map[string]string)
	    err = json.Unmarshal([]byte(msg), &msgmap)
	    if err != nil {
		log.Error("===============socket client,unmarshal msg to map error=============","err",err)
		time.Sleep(time.Duration(1000000))
		continue
	    }
	  
	    /////add for get tee param data
	   /*
	   _,ok := msgmap["TeeParamData"]
	    if ok {
		TeeParamDataCh <-msg
		continue
	    }
	    */
	    _,ok := msgmap["attestation"]
	    if ok {
		AttestationCh <-msg
		continue
	    }
	    _,ok = msgmap["enc_datakey"]
	    if ok {
		DataKeyCh <-msg
		continue
	    }
	    _,ok = msgmap["tee_enodeID"]
	    if ok {
		TeeEnodeIDCh <-msg
		continue
	    }
	    /////

	    w,err := FindWorker(msgmap["Key"])
	    if w == nil || err != nil {
		log.Error("==============socket client,not found worker================")
		time.Sleep(time.Duration(1000000))
		continue
	    }

	    log.Info("==============socket client,continue the msg================","msg",msg)
	    w.OutCh <-msg
	    ///////
	}
    }
}


